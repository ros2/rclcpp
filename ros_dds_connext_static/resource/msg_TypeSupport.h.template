@###############################################
@#
@# ROS message type support code generation for C++
@#
@# EmPy template for generating <msg>_TypeSupport.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@###############################################

#ifndef __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__
#define __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__

#include <iostream>

#include "@(spec.base_type.pkg_name)/@(spec.base_type.type)_Struct.h"
#include "@(spec.base_type.pkg_name)/dds_idl/@(spec.base_type.type)_Support.h"
#include "rosidl_generator_cpp/MessageTypeSupport.h"
#include "ros_dds_connext_static/MessageTypeSupport.h"

namespace @(spec.base_type.pkg_name)
{

namespace type_support
{

void register_type__@(spec.base_type.type)(DDSDomainParticipant * participant, const char * type_name)
{
    std::cout << "  @(spec.base_type.pkg_name)::type_support::register_type__@(spec.base_type.type)()" << std::endl;
    @(spec.base_type.pkg_name)::dds_idl::@(spec.base_type.type)_TypeSupport::register_type(participant, type_name);
}

void convert_ros_message_to_dds__@(spec.base_type.type)(const void * untyped_ros_message, @(spec.base_type.pkg_name)::dds_idl::@(spec.base_type.type)_& dds_message)
{
    std::cout << "  @(spec.base_type.pkg_name)::type_support::convert_ros_message_to_dds__@(spec.base_type.type)()" << std::endl;
    const @(spec.base_type.pkg_name)::@(spec.base_type.type) & ros_message = *(const @(spec.base_type.pkg_name)::@(spec.base_type.type) *)untyped_ros_message;
@[for field in spec.fields]@
    // field.name @(field.name)
    // field.type @(field.type)
    // field.type.is_array @(field.type.is_array)
@[if field.type.array_size]@
    // field.type.array_size @(field.type.array_size)
@[else]@
    // field.type.array_size dynamic
@[end if]@
@[if field.type.is_array]@
    {
@[if field.type.array_size]@
        size_t size = @(field.type.array_size);
@[else]@
        size_t size = ros_message.@(field.name).size();
        dds_message.@(field.name)_.length(size);
@[end if]@
        for (size_t i = 0; i < size; i++) {
@[if field.type.is_primitive_type()]@
            dds_message.@(field.name)_[i] = ros_message.@(field.name)[i];
@[else]@
            ::dds_impl::DDSTypeResolver<@(field.type.pkg_name)::@(field.type.type)>::convert_ros_message_to_dds(ros_message.@(field.name)[i], dds_message.@(field.name)_[i]);
@[end if]@
        }
    }
@[elif field.type.is_primitive_type()]@
      dds_message.@(field.name)_ = ros_message.@(field.name);
@[else]@
      ::dds_impl::DDSTypeResolver<@(field.type.pkg_name)::@(field.type.type)>::convert_ros_message_to_dds(ros_message.@(field.name), dds_message.@(field.name)_);
@[end if]@

@[end for]@
}

void publish__@(spec.base_type.type)(DDSDataWriter * topic_writer, const void * ros_message)
{
    std::cout << "  @(spec.base_type.pkg_name)::type_support::publish__@(spec.base_type.type)()" << std::endl;

    @(spec.base_type.pkg_name)::dds_idl::@(spec.base_type.type)_ dds_message;
    convert_ros_message_to_dds__@(spec.base_type.type)(ros_message, dds_message);

    @(spec.base_type.pkg_name)::dds_idl::@(spec.base_type.type)_DataWriter * data_writer = @(spec.base_type.pkg_name)::dds_idl::@(spec.base_type.type)_DataWriter::narrow(topic_writer);
    std::cout << "  @(spec.base_type.pkg_name)::type_support::publish__@(spec.base_type.type)() write dds message" << std::endl;
    DDS_ReturnCode_t status = data_writer->write(dds_message, DDS_HANDLE_NIL);
    if (status != DDS_RETCODE_OK) {
        printf("write() failed. Status = %d\n", status);
        throw std::runtime_error("write failed");
    };
}


static ros_dds_connext_static::MessageTypeSupportCallbacks callbacks = {
    "@(spec.base_type.pkg_name)",
    "@(spec.base_type.type)",
    &register_type__@(spec.base_type.type),
    &publish__@(spec.base_type.type)
};

static rosidl_generator_cpp::MessageTypeSupportHandle handle = {
    ros_dds_connext_static::_connext_static_identifier,
    &callbacks
};

}  // namespace type_support

}  // namespace @(spec.base_type.pkg_name)


namespace rosidl_generator_cpp
{

template<>
struct MessageTypeSupport<@(spec.base_type.pkg_name)::@(spec.base_type.type)>
{
    static const rosidl_generator_cpp::MessageTypeSupportHandle& get_type_support_handle()
    {
        return @(spec.base_type.pkg_name)::type_support::handle;
    }
};

}  // namespace rosidl_generator_cpp

#endif  // __@(spec.base_type.pkg_name)__@(spec.base_type.type)_TypeSupport__h__
